almostDisj:  expr '/' '1' expr
;
assertion:   implication '.'
;
assignment:  identifier '=' expr ';'
          |  string_literal '=' expr ';'
          |  identifier '=' partition ';'
;
attribute:   identifier
;
big:         expr '/' '!' expr
;

implication: 
             implication '-' '>' implication
          |  implication '<' '-' implication
          |  implication '<' '-' '>' implication
          |  disjunction
          |  '(' implication ')'
;

filename:
           identifier
         | identifier '.' identifier
         | string_literal
;

include: 'include' filename ';'
;


disjunction: 
             conjunction '|' disjunction
          |  conjunction 
          |  '(' disjunction ')'
;

conjunction: 
             proposition '&' conjunction
          |  proposition 
          |  '(' conjunction ')'
          |   '-' '(' conjunction ')'
;

oper:       '^'
          | 'v'
          | userOper
;

proposition:     
             "not to confuse with userOper"
          |  expr '=' expr
          |  expr '~' expr
          |  partition '<' partition
          |  partition '=' partition
          |  partition '>' partition
          |  expr '!' '=' expr
          |  expr '<' '~' expr
          |  expr '>' '~' expr
          |  oper '!' '=' oper
;

"not to confuse with userOper":
             expr '<' expr
          |  expr '>' expr
;

complement:  identifier 'qtSymbol'
          |  parExpr 'qtSymbol'
;
contains:     expr '/' '<' expr
;
content:     value
          |  content value
;
database:    assignment
          |  database assignment
;
disjoint:    expr '/' '0' expr
;
expr:        almostDisj
          |  big
          |  complement
          |  contains
          |  disjoint
          |  identifier
          |  string_literal
          |  innerUnion
          |  inverse
          |  join
          |  parExpr
          |  relation
          |  setEQ
          |  setIX
          |  table
          |  transpCont
          |  unnamedJoin
          |  unnamedMeet
          |  userDefined
;
header:      identifier
          |  string_literal
          |  header identifier
          |  header ',' identifier
;
innerUnion:  expr 'v' expr
;
inverse:     identifier '`'
          |  parExpr '`'
;
join:        expr '^' expr
;
parExpr:     '(' expr ')'
;
partition:  
            '(' partition ')'
          |  expr '#' expr
          |  partition '^' partition
          |  partition 'v' partition
          
          --|  content
          --|  partition '|' content      
          |  tuple
          |  partition '|' tuple      
;
program:   stmt  
          |  stmt program
;
query:       expr ';'
          |  partition ';'
;

/* set-theoretic notation; deprecated. Use table syntax 
relation:    '{' tuples '}'
;
tuple:       '<' values '>'
;
tuples:      tuple
          |  tuples ',' tuple
;
values:      namedValue
          |  values ',' namedValue
;
namedValue:  attribute '=' value
;
*/

setEQ:       expr '/' '=' expr
;
setIX:       expr '/' '^' expr
;

stmt:        assertion
          |  assignment
          |  query
          |  include
;

table:       '[' ']'
          |  '[' header ']'
          |  '[' header ']' content
/*        |  '[' identifier '=' identifier ']'  - deprecated. Use string literals, e.g. "x=y"*/
;
transpCont:  expr '/' '>' expr
;
unnamedJoin:  expr '^' '~' expr
;
unnamedMeet:  expr 'v' '~' expr
;
userDefined:  userOper expr -- prefix
           |  expr userOper expr -- infix
;
userOper:  '<' identifier '>'
          | '<' string_literal '>'
;
value:       digits
          |  '-' digits
          |  identifier
          |  string_literal
          |  /* nested relation */ parExpr          
;
