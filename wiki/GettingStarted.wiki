#summary On this page we describe how to create a small database and check assertions against it.

----
== Programmatic Environment ==

QBQL is implemented in java. Therefore, for java person the most natural way to get it running is to install _Eclipse_, _Subversion_ plugin, and then check out the source from _google_ _code_ svn. All these steps are standard and are documented elsewhere.

Alternatively, you can download [http://qbql.googlecode.com/svn/trunk/dist/qbql.jar qbql.jar] and run it from the command line as follows:

{{{
C:\> java -jar C:\qbql_trunk\dist\qbql.jar C:\qbql_tr
unk\src\qbql\program\strings.db C:\qbql_trunk\src\qbql\program\strings.prg
}}} 

Before proceeding to the next section (which is written in cookbook style) a reader is advised to read QBQL introductory articles 
 * [http://vadimtropashko.wordpress.com/relational-programming-with-qbql/ Part 1]
 * [http://vadimtropashko.wordpress.com/relational-programming-with-qbql/manipulating-strings-in-qbql/ Part 2]
 * [http://vadimtropashko.wordpress.com/relational-programming-with-qbql/aggregation-and-set-joins/ Part 3]

== Database ==

To create a _database_ you need to describe it in a text file. Sometimes you don't need any relations, or would like to create them on-the-fly, then you create an empty database definition file. For example, `strings.db` -- file containing string manipuluation examples from [http://vadimtropashko.wordpress.com/relational-programming-with-qbql/manipulating-strings-in-qbql/ Programming QBQL series, part 2] is empty, because the discussion revolves around predicates and not relations. The file name is supplied as the first argument to QBQL program; if there is no argument, then QBQL defaults to database name hardcoded in the Run.java.

The syntax for [http://code.google.com/p/qbql/source/browse/trunk/src/qbql/lattice/lattice.grammar QBQL grammar] allows defining relations in the following format
 
{{{
relation_var = [ attribute1 attribute2 ...] value1 value2 ...;
}}}

For example, the fragment

{{{
Blocks=[name  shape  size]
        a     tet    small
        b     cube   small
        c     cube   medium
        d     cube   large
        e     dodec  large
        f     tet    large
;

Large=[size]
       large
;
}}}

specifies two relations named `Blocks` and `Large` from `Wittgenstein.db` for a database of geometric shapes borrowed from [http://ggww2.stanford.edu/GUS/lpl/ Language, Proof, and Logic] textbook.

After definining several relations, you may build new relations from the existing ones by applying [http://vadimtropashko.wordpress.com/relational-lattice/ relational lattice] operations. The files with the `.db` extension in the qbql/program package are database definition files:
 * `Wittgenstein.db` - a small introductory database of geometric shapes borrowed from LPL textbook
 * `Figure1.db` - relational lattice instance from the Figure 1 http://arxiv1.library.cornell.edu/pdf/0807.3795
 * `Sims.db` - less abstract database of people mainly used for researching set joins.
 * `strings.db` - string examples from [http://vadimtropashko.wordpress.com/relational-programming-with-qbql/manipulating-strings-in-qbql/ Programming QBQL series, part 2] (empty). 
 * `Aggregate.db` - database dedicated to studying aggregates containing the familiar EMP and DEPT tables from oracle database. (Currently it fails to initialize due to the size of the universal relation `R11`). 

Watch out for [http://code.google.com/p/qbql/wiki/CurrentLimitations pitfalls]. 

== Assertions/Program ==
 
A program is a sequence of _assignment operations_ and _assertions_. Assertions are either equalities 

{{{
expr1 = expr2.
expr3 = expr4.
...
}}}

or inequalities

{{{
expr1 < expr2.
expr3 > expr4.
...
}}}

or complex assertions built with boolean operations out of primitive equalities and inequalities. Each expression on left-hand and right-hand side of an equality or inequality is either a relation/predicate variable, or a term built via operations of join `^`, inner union `v`, outer union `+`, inner join `*`, negation `'`, or set join applied to relations/predicates. See [http://code.google.com/p/qbql/source/browse/trunk/src/qbql/lattice/lattice.grammar QBQL grammar] for the details.

For example, the `Wittgenstein.assertions` file 

{{{
(Blocks ^ D) v Size = Large.
(Blocks ^ A) v Size = Small.
(((A ^ Left) v Comparison) ^ (D ^ Right)) v R00 = R01.
}}} 
   
claims the following propositions

{{{
"D is a Large Block"
"A is a Small Block"
"A is smaller than D"
}}}

The name of the database assertions/program text file is specified as the second argument to QBQL program, otherwise the one hard coded in the beginning of `Run.java` file is used. 

== Run the program ==

Now you are set. Just run the Run.main() and watch the console output. If the database satisfies all the assertions then the expected output is

`All Assertions are OK`

otherwise it would print out the offending assertion and the values of the variables. This variables assigment can be literally copied and pasted into back to the assertion/program file, and you can also split the invalid assertion into smaller pieces to evaluate them individulally. Let's check the inner join associativity

{{{
x * (y * z) = y * (x * z).
}}}

in `Figure1.db` example. Paste this assertion into `Figure1.prg`, and witness the output:

{{{
z = [q]
     c
;
y = [p  q]
     1  a
     1  b
     2  a
;
x = [p]
     1
;
}}}   

Then, replace the assertion with the following program:

{{{
z = [q]
     c
;
y = [p  q]
     1  a
     1  b
     2  a
;
x = [p]
     1
;
y * z;
x * z;
x * (y * z);
y * (x * z);
}}}   