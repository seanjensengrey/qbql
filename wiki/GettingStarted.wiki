#summary On this page we describe how to create a small database and check assertions against it.

----
== Programmatic Environment ==

QBQL is written in java. Therefore, until QBQL elevates to more sophisticated interface, the only way to get it running is to install _Eclipse_, _Subversion_ plugin, and then check out the source from _google_ _code_ svn. All these steps are standard and are documented elsewhere.

Before proceeding to the next section (which is written in cookbook style) a reader is advised to read QBQL introductory articles 
 * [http://vadimtropashko.wordpress.com/relational-programming-with-qbql/ Part 1]
 * [http://vadimtropashko.wordpress.com/relational-programming-with-qbql/manipulating-strings-in-qbql/ Part 2]
 * [http://vadimtropashko.wordpress.com/relational-programming-with-qbql/aggregation-and-set-joins/ Part 3]

== Database ==

To create a _database_ you need to describe it in a text file. The syntax for 
[http://code.google.com/p/qbql/source/browse/trunk/src/qbql/lattice/lattice.grammar
QQBQL grammar] consists of two parts. You either specify the relation in set-theoretic notation explicitly

{{{
relation_var = {<attribute1=value1, attribute2=value2,...>,<attribute1=value3, attribute2=value4, ...>, ...};
}}}

or in arguably more conventional database notation
 
{{{
relation_var = [ attribute1 attribute2 ...] value1 value2 ...;
}}}

There are no tuples in conventional notation, only value position modulo number of attributes matters. For example, the fragment

{{{
Blocks = {
  <name=a,shape=tet,size=small>,
  <name=b,shape=cube,size=small>,
  <name=c,shape=cube,size=medium>,
  <name=d,shape=cube,size=large>,
  <name=e,shape=dodec,size=large>,
  <name=f,shape=tet,size=large>
};

Large = {<size=large>};
}}}

in set notation or, equivalently

{{{
Blocks=[name  shape  size]
        a     tet    small
        b     cube   small
        c     cube   medium
        d     cube   large
        e     dodec  large
        f     tet    large
;

Large=[size]
       large
;
}}}

in conventional notation defines two relations named `Blocks` and `Large` from `Wittgenstein.db` for a database of geometric shapes borrowed from [http://ggww2.stanford.edu/GUS/lpl/ Language, Proof, and Logic] textbook.

After definining several relations, you may build new relations from the existing ones by applying [http://vadimtropashko.wordpress.com/relational-lattice/ relational lattice] operations. The files with the `.db` extension are database definition files:
 * `Wittgenstein.db` - a small introductory database of geometric shapes borrowed from LPL textbook
 * `Figure1.db` - relational lattice instance from the Figure 1 http://arxiv1.library.cornell.edu/pdf/0807.3795
 * `Sims.db` - less abstract database of people mainly used for researching set joins.
 * `Aggregate.db` - database dedicated to studying aggregates containing the familiar EMP and DEPT tables from oracle database. (Currently it fails to initialize due to the size of the universal relation R11). 

Watch out for *pitfalls*. Predefined relation constants `R00`, `R01` are database independent and, therefore are calculated before database creation. `R10` and `R11`, however, are infinite relations, which makes them impossible to implement as sets of tuples. Yet, for any given database instance there are finite incarnations of `R10`, `R11` which satisfy all RL axioms. Consequently, `R10` and `R11` are not defined until the very last base relation is added to the database. In other words, you can use `R00`, `R01` in relational expression within database definition file, but not `R10` and `R11`. Likewise, outer union and complement leverage the `R11` definition and, therefore, can't be used in the database definition file.  

The name of the database definition text file is hard coded in the beginning of `Database.java` file. 

== Assertions/Program ==
 
You define _assertions_ as equations 

{{{
expr1 = expr2.
expr3 = expr4.
...
}}}

in a text file as well. Each expression is either a relational variable, or terms built with operations of join `^`, inner union `v`, outer union `+`, inner join `*`, and negation `'` applied to relations. See [http://code.google.com/p/qbql/source/browse/trunk/src/qbql/lattice/lattice.grammar
QQBQL grammar] for the details.

For example, the `Wittgenstein.assertions` file 

{{{
(Blocks ^ D) v Size = Large.
(Blocks ^ A) v Size = Small.
(((A ^ Left) v Comparison) ^ (D ^ Right)) v R00 = R01.
}}} 

   
claims the following propositions

{{{
"D is a Large Block"
"A is a Small Block"
"A is smaller than D"
}}}

The name of the assertions text file is hard coded in the beginning of `Database.java`.

== Run the program ==

Now you are set. Just run the Run.main() and watch the console output. If the database satisfies all the assertions then the expected output is

`All Assertions are OK`

otherwise it would print out the offending assertion and the values of the variables. This variables assigment can be literally copied and pasted into back to the assertion/program file, and you can also split the invalid assertion into smaller pieces to evaluate them individulally. Let's check the inner join associativity

{{{
x * (y * z) = y * (x * z).
}}}

in `Figure1.db` example. Paste this assertion into `Figure1.prg`, and witness the output:

{{{
z = [q]
     c
;
y = [p  q]
     1  a
     1  b
     2  a
;
x = [p]
     1
;
}}}   

Then, replace the assertion with the following program:

{{{
z = [q]
     c
;
y = [p  q]
     1  a
     1  b
     2  a
;
x = [p]
     1
;
y * z;
x * z;
x * (y * z);
y * (x * z);
}}}   